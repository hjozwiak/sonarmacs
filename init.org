#+title: The Sonarmacs Environment
#+author: The Sonarmacs Community
#+description: Configuration and documentation for the Sonarmacs environment
#+language: en
#+startup: fold

* Introduction
This is a configuration for Emacs based on the speech dispatcher software, which is a utility for providing speech output for blind and visually impaired persons. Additionally, Braille support is provided with the brltty software.
** Required System Packages
In order for this configuration to work, you will need to have several things installed on your system:
- Emacs
- speechd-dispatcher
- brltty

#+begin_note
brltty is not a hard requirement, and at the time of this writing I have not had a Braille display to test the brltty integration; YMMV.
#+end_note
** Getting Around this File
If you are reading this file in Emacs, you will have discovered that it is written in org-mode and the configuration itself is tangled from here.

Here are some things to note:
- interact with the source blocks by pressing C-', which puts you into a special edit mode
- The sections of the document are folded, so you will need to press TAB on the section you want to see the children of.
** Getting In Touch
If you want to get in touch with fellow users or submit patches, here are the mailing lists.
| name               | purpose                                       | subscribe                                          | communicate                             |
|--------------------+-----------------------------------------------+----------------------------------------------------+-----------------------------------------|
| sonarmacs-announce | Announcement list (will probably not be used) | [[mailto:~hjozwiak/sonarmacs-announce+subscribe@lists.sr.ht][~hjozwiak/sonarmacs-announce+subscribe@lists.sr.ht]] | n/a                                     |
| sonarmacs-discuss  | general user discussions                      | [[mailto:~hjozwiak/sonarmacs-discuss+subscribe@lists.sr.ht][~hjozwiak/sonarmacs-discuss+subscribe@lists.sr.ht]]  | [[mailto:~hjozwiak/sonarmacs-discuss@lists.sr.ht][~hjozwiak/sonarmacs-discuss@lists.sr.ht]] |
| sonarmacs-devel    | submit your patches here                      | [[mailto:~hjozwiak/sonarmacs-devel+subscribe@lists.sr.ht][~hjozwiak/sonarmacs-devel+subscribe@lists.sr.ht]]    | [[mailto:~hjozwiak/sonarmacs-devel@lists.sr.ht][~hjozwiak/sonarmacs-devel@lists.sr.ht]]   |
* Early Initialization
:properties:
:header-args:emacs-lisp: :tangle ./early-init.el :lexical yes
:END:

There are a few things that one might want to do before Emacs starts loading the initialization file, such as customizing the initial frame, increasing the garbage collection threshhold, etc.
** Disable Some UI Elements
For our purposes, we don't really need to have the toolbars or menu bars active by default. If you should want to use something that is provided in the menu bars, you can get at them with F10.
#+begin_src emacs-lisp
  ;; -*- lexical-binding: t; -*-
  (setq inhibit-startup-message t
  toolbar-mode nil
  menu-bar-mode nil)
  (push '(tool-bar-lines . 0) default-frame-alist)
  (push '(menu-bar-lines . 0) default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)
#+end_src


* Initialization File
:properties:
:header-args:emacs-lisp: :tangle ./init.el :lexical yes
:END:

Here is where the bulk of the initialization takes place, in a file called init.el.

There are many ways in which to customize Emacs:
- some prefer to modularize the configuration
- Some like to have a literate config
- Or maybe have one giant configuration file.

The initial configuration will be a literate config. In so doing, we can both provide the code that Emacs Will run in addition to providing further user-facing documentation.
** The Package System
*** Configuring Sources
There are three package sources that we use by default:
- Melpa :: The place that has the most packages, which I have been using for years now.
- ELPA :: The GNU packages.
- non-GNU ELPA :: The repository for packages that don't quite meet the FSF guidelines.

#+begin_src emacs-lisp
  ;; -*- lexical-binding: t; -*-
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  #+end_src
*** Set the Priorities
#+begin_src emacs-lisp
  (customize-set-variable 'package-archive-priorities '(("melpa" . 10) ("gnu" . 9) ("nongnu" . 8)))
#+end_src
** Setup Installation
#+begin_src emacs-lisp
  (unless (package-installed-p 'setup)
    (package-install 'setup))
  (require 'setup)
#+end_src
*** Some Definers
**** Run Code After Init
There is a hook called after-init-hook that you can use to run code after Emacs has finished initializing.
#+begin_src emacs-lisp
  (setup-define :after-init
    (lambda (&rest body)
      `(if after-init-time (progn ,@body) (add-hook 'after-init-hook (lambda () ,@body)))
    :documentation "Run the specified body after Emacs has finished initializing."
    :signature '(body ...))
#+end_src
**** Run Code After the First Frame is Made
This is particularly useful if you run Emacs as a daemon and you would like to launch a particular package (the speedbar, for example) when you open your first frame in either the GUI or TTY.
#+begin_src emacs-lisp
  (setup-define :after-gui
    (lambda (&rest body)
      `(if (and (not (daemonp)) (display-graphic-p))
           (progn ,@body)
         (add-hook 'server-after-make-frame-hook (lambda ()
                                                   (when (display-graphic-p)
                                                     ,@body
                                                     t)))))
    :documentation "Run body after the first graphical frame is created."
    :signature '(BODY ...))

  (setup-define :after-tty
    (lambda (&rest body)
      `(if (and (not (daemonp)) (not (display-graphic-p)))
           (progn ,@body)
         (add-hook 'server-after-make-frame-hook (lambda ()
                                                   (unless (display-graphic-p)
                                                     ,@body
                                                     t)))))
    :documentation "Run body after the first TTY frame is created."
    :signature '(body ...))
#+end_src
** speechd-el
The configuration of speechd-el is quite immense, so this section is meant more as a guide as to how to do it rather than something that is set in stone; feel free to tweak things to your liking.
#+begin_src emacs-lisp
  (setup
      (:package speechd-el)
    (:option
     speechd-speak-whole-line t
     speechd-speak-echo nil
     speechd-speak-read-command-keys nil
     speechd-voices '((nil
                             (rate . 100)
                             (output-module . "espeak-ng"))))
    (speechd-speak))
#+end_src
*** Helper Functions
**** Retrieve a Reading Function
In order to make definers for setup, we need to first make functions that will return functions that are defined in speechd-speak. For example, the reading functions speechd-speak-read-paragraph, sentence, etc.
#+begin_src emacs-lisp
  (defun retrieve-speechd-function (thing)
    "Retrieve the function that is defined by speechd-el.

  Usually it is the form of speechd-speak-read-<thing>"
    (cl-loop for s being the symbols
	     when (string-match (concat "speechd-speak-read-" thing) (symbol-name s))
	     when (fboundp s)
	     return s))
#+end_src
**** Post Motion Feedback Defining Macro
For most entities, we can get away with just calling the function, since they don't really take any arguments. The one exception I've found thus far is speechd-speak-read-line, who wants an argument whether or not to read the whole line; we will deal with this case later.
#+begin_src emacs-lisp
  (cl-loop for ent in '("paragraph" "sentence" "word" "character" "sexp")
	   for doc = (format "Advise the functions that move by %s to report the new %s after movement." ent ent)
	   for setup-name = (intern (concat ":" ent "-feedback"))
	   for speechd-command = (retrieve-speechd-function ent)
	   when (fboundp speechd-command) do
	   (eval
	    `(setup-define ,setup-name
	       (lambda (&rest funcs)
		 `(speechd-speak--command-feedback ,funcs after (funcall speechd-command)))
	       :documentation ,doc
	       :signature '(command ...))))
#+end_src
** No Littering
By default, Emacs will pollute your configuration directory with various auto-save, cache and configuration files. The aim of the no littering package is to keep the configuration directory relatively clean, by putting persistant information into the var subdirectory and configuration files in etc.
#+begin_src emacs-lisp
  (setup
      (:package no-littering)
    (:require no-littering)
  (:option
    auto-save-name-transforms `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))
  custom-file (no-littering-expand-etc-file-name "custom.el"))))
#+end_src

# Local Variables:
# eval: (add-hook 'before-save-hook #'org-babel-tangle nil t)
# End:
