#+title: The Sonarmacs Environment
#+author: The Sonarmacs Community
#+description: Configuration and documentation for the Sonarmacs environment
#+language: en
#+startup: fold

* Introduction
This is a configuration for Emacs based on the speech dispatcher software, which is a utility for providing speech output for blind and visually impaired persons. Additionally, Braille support is provided with the brltty software.
** Required System Packages
In order for this configuration to work, you will need to have several things installed on your system:
- Emacs
- speechd-dispatcher
- brltty

#+begin_note
brltty is not a hard requirement, and at the time of this writing I have not had a Braille display to test the brltty integration; YMMV.
#+end_note
** Getting Around this File
If you are reading this file in Emacs, you will have discovered that it is written in org-mode and the configuration itself is tangled from here.

Here are some things to note:
- interact with the source blocks by pressing C-', which puts you into a special edit mode
- The sections of the document are folded, so you will need to press TAB on the section you want to see the children of.
** Getting In Touch
This repository is now hosted on Github, so you can [[https://github.com/hjozwiak/sonarmacs/compare][submit pull requests]] and [[https://github.com/hjozwiak/sonarmacs/issues/new][file issues]] there.

* Early Initialization
:properties:
:header-args:emacs-lisp: :tangle ./early-init.el :lexical yes
:END:

There are a few things that one might want to do before Emacs starts loading the initialization file, such as customizing the initial frame, increasing the garbage collection threshhold, etc.
** Disable Some UI Elements
For our purposes, we don't really need to have the toolbars or menu bars active by default. If you should want to use something that is provided in the menu bars, you can get at them with F10.
#+begin_src emacs-lisp
  ;; -*- lexical-binding: t; -*-
  (setq inhibit-startup-message t
  toolbar-mode nil
  menu-bar-mode nil)
  (push '(tool-bar-lines . 0) default-frame-alist)
  (push '(menu-bar-lines . 0) default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)
#+end_src


* Initialization File
:properties:
:header-args:emacs-lisp: :tangle ./init.el :lexical yes
:END:

Here is where the bulk of the initialization takes place, in a file called init.el.

There are many ways in which to customize Emacs:
- some prefer to modularize the configuration
- Some like to have a literate config
- Or maybe have one giant configuration file.

The initial configuration will be a literate config. In so doing, we can both provide the code that Emacs Will run in addition to providing further user-facing documentation.
** The Package System
*** Configuring Sources
There are three package sources that we use by default:
- Melpa :: The place that has the most packages, which I have been using for years now.
- ELPA :: The GNU packages.
- non-GNU ELPA :: The repository for packages that don't quite meet the FSF guidelines.

#+begin_src emacs-lisp
  ;; -*- lexical-binding: t; -*-
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  #+end_src
*** Set the Priorities
#+begin_src emacs-lisp
  (customize-set-variable 'package-archive-priorities '(("melpa" . 10) ("gnu" . 9) ("nongnu" . 8)))
#+end_src
** use-package Installation
#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
#+end_src
** speechd-el
The configuration of speechd-el is quite immense, so this section is meant more as a guide as to how to do it rather than something that is set in stone; feel free to tweak things to your liking.
#+begin_src emacs-lisp
  (use-package speechd-el
    :ensure t
    :demand t
    :custom
     (speechd-speak-whole-line t)
     (speechd-speak-echo nil)
     (speechd-speak-read-command-keys nil)
     (speechd-voices '((nil
                             (rate . 100)
                             (output-module . "espeak-ng"))))
  :config
  (speechd-speak))
#+end_src
*** Helper Functions
**** Retrieve a Reading Function
In order to make definers for use-package, we need to first make functions that will return functions that are defined in speechd-speak. For example, the reading functions speechd-speak-read-paragraph, sentence, etc.
#+begin_src emacs-lisp
  (defun retrieve-speechd-function (thing)
    "Retrieve the function that is defined by speechd-el.

  Usually it is the form of speechd-speak-read-<thing>"
    (cl-loop for s being the symbols
             when (string-match (concat "speechd-speak-read-" thing) (symbol-name s))
             when (fboundp s)
             return s))
#+end_src
** No Littering
By default, Emacs will pollute your configuration directory with various auto-save, cache and configuration files. The aim of the no littering package is to keep the configuration directory relatively clean, by putting persistant information into the var subdirectory and configuration files in etc.
#+begin_src emacs-lisp
  (use-package no-littering
    :ensure t
    :demand t
    :hook (after-init . (lambda () (load custom-file)))
    :custom
    (auto-save-name-transforms `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
    (custom-file (no-littering-expand-etc-file-name "custom.el")))
#+end_src
** Which Key
As you input keys into Emacs, which-key will interactively filter the currently available options and present the commands and their keybindings. As it is right now, which-key will wait one second before printing its output to the minibuffer for speechd-el to read. If you should do something that prints out a large keymap, i.e. ctl-x, it will barf everything out in one go; I need to figure out a solution for this as yet.
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :custom
    (which-key-idle-delay 1.0)
    (which-key-compute-remaps t)
    (which-key-popup-type 'minibuffer)
    (which-key-show-transient-maps t)
    :init
    (which-key-mode))
#+end_src
** General.el
General is a nifty utility for easily defining keybindings, as well as having some useful utilities for running code after initialization of Emacs, after the first GUI and/or TTY frame is created, and setting custom user options.
#+begin_src emacs-lisp
  (use-package general
    :ensure t
    :demand t
    :config
    (general-auto-unbind-keys)
    (general-evil-setup t)
    ;; Create the leader definer
    (general-create-definer mapleader
      :prefix "SPC"
      :global-prefix "C-SPC"
      :states '(normal visual insert emacs))
    (mapleader
     "b" '(:ignore t :which-key "Buffer operations")
     "bn" '(next-buffer :which-key "Go to the next buffer.")
     "bp" '(previous-buffer :which-key "Go to the previous buffer.")
     "bb" '(switch-to-buffer :which-key "Switch to a buffer.")
     "bj" '(:ignore t :which-key "Jumping to specific buffers.")
     "bjd" '(dired-jump :which-key "Go to a dired window.")
     "bjm" '((lambda () (interactive) (switch-to-buffer (messages-buffer))) :which-key "Jump to messages buffer.")
     "bjw" '((lambda () (interactive) (switch-to-buffer "*Warnings*")) :which-key "Go to the warnings buffer.")
     "bjs" '((lambda () (interactive) (switch-to-buffer "*scratch*")) :which-key "Switch to the scratch buffer.")
     "bi" '(ibuffer :which-key "Interactive buffer management through the Ibuffer interface.")
     "br" '(revert-buffer :which-key "Revert the buffer to how it is on disk.")
     ;; Customization
     "c" '(:ignore t :which-key "Customization interface.")
     "cc" '(customize :which-key "Open the customization index.")
     "cf" '(customize-face :which-key "Customize a face.")
     "cg" '(customize-group :which-key "Customize a specific group.")
     "cv" '(customize-variable :which-key "Customize a variable in the custom interface.")
     "cV" '(customize-set-variable :which-key "Expert level variable setting, sans interface.")
     "f" '(:ignore t :which-key "File operations.")
     "fs" '(save-buffer :which-key "Save your currently opened file.")
     "ff" '(find-file :which-key "Find a file.")
     "fd" '(dired :which-key "Open a dired buffer.")
     ;; Frame operations
     "F" '(:ignore t "Frames.")
     "Fd" '(delete-frame :which-key "Delete this frame.")
     "Fo" '(other-frame :which-key "Go to another frame.")
     "h" '(:ignore t :which-key "Help")
     "hd" '(:ignore t :which-key "Describe parts of Emacs.")
     "hdb" '(describe-bindings :which-key "Describe the keybindings that are in effect right now.")
     "hdB" '(general-describe-keybindings :which-key "Get a list of the key bindings that are in effect via General.")
     "hdf" '(describe-function :which-key "Describe a function.")
     "hdF" '(describe-face :which-key "Describe a face.")
     "hdk" '(describe-key :which-key "Describe what a key is bound to.")
     "hdp" '(describe-package :which-key "Describe a package.")
     ;; Info manuals
     "hi" '(:ignore t :which-key "Info")
     "hia" '(info-apropos :which-key "Search the info database.")
     "hii" '(info-index :which-key "Open the info index.")
     "him" '(info-display-manual :which-key "Open a specific info manual.")))
  ;; Aliases
  (defalias 'setc #'general-setq "A convenience alias for setting customizable variables.")
#+end_src
** Evil Mode
Evil is a system for providing vim-like keybindings in Emacs.
**** Undo Tree
Our preferred undo system for Evil mode.
#+begin_src emacs-lisp
  (use-package undo-tree
    :init
    (global-undo-tree-mode)
    :ensure t)
#+end_src
**** Evil Itself
#+begin_note
There are a few things that we need to set before Evil itself is loaded.
#+end_note
#+begin_src emacs-lisp
  (use-package evil
    :ensure t
    :custom
    (evil-echo-state nil)
    (evil-want-integration t)
    (evil-want-c-i-jump nil)
    (evil-want-keybind nil)
    (evil-undo-system 'undo-tree)
    :preface
    (defun sonarmacs--evil-state-change-notify ()
      (when (and evil-next-state evil-previous-state (not (eq evil-previous-state evil-next-state)))
        (speechd-say-text (format "Changing state from %s to %s." evil-previous-state evil-next-state) :priority 'important)))
    :hook ((evil-insert-state-exit evil-normal-state-exit evil-motion-state-exit evil-operator-state-exit evil-replace-state-exit evil-visual-state-exit evil-emacs-state-exit) . sonarmacs--evil-state-change-notify)
    :general
    (:states '(normal visual insert operator replace motion)
             speechd-speak-prefix speechd-speak-mode-map)
    (speechd-speak-mode-map
     "e" 'evil-scroll-line-down)
     :init
     (evil-mode)
     :config
     (speechd-speak--command-feedback (evil-next-line evil-previous-line evil-next-visual-line evil-previous-visual-line evil-beginning-of-line) after (speechd-speak-read-line (not speechd-speak-whole-line)))
     (speechd-speak--command-feedback (evil-forward-paragraph evil-backward-paragraph) after
                                      (speechd-speak-read-paragraph))
     (speechd-speak--command-feedback (evil-forward-word-begin evil-backward-word-begin evil-backward-word-end evil-forward-word-end) after (speechd-speak-read-word))
     (speechd-speak--command-feedback (evil-backward-char) after (speechd-speak-read-char (following-char)))
     (speechd-speak--command-feedback (evil-forward-char) after (speechd-speak-read-char (preceding-char))))
#+end_src
**** Evil Collection
For the mass evilification of modes.
#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :ensure t
    :config
    (evil-collection-init))
#+end_src

** Version Control
*** Magit and Friends
Magit is the really handy git porcilin for Emacs, which I have used for years.
**** Transient
#+begin_src emacs-lisp
  (use-package transient
    :ensure t
    :custom
    (transient-show-popup t)
    (transient-enable-popup-navigation t)
    (transient-force-single-column t)
    :config
    (speechd-speak--command-feedback (transient-forward-button transient-backward-button) after
                                     (with-current-buffer (window-buffer transient--window)
                                       ;; Get at the button to speak.
                                       (when-let ((button (button-at (point)))
                                                  (start (button-start button))
                                                  (end (button-end button)))
                                         (speechd-speak-read-region start end)))))
#+end_src
**** Core Magit
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :custom
    (magit-delete-by-moving-to-trash nil)
    :general
    (mapleader
      "g" '(:ignore t :which-key "Git operations.")
      "gg" '(magit-status :which-key "Magit status.")
      "gs" '(magit-stage-file :which-key "Stage the working file."))
    :config
    (magit-add-section-hook 'magit-status-sections-hook 'magit-insert-modules 'magit-insert-stashes 'append))
#+end_src
**** Forges
Various git services, such as Github, Gitlab, and SourceHut.
#+begin_src emacs-lisp
  (use-package forge
    :after magit
    :ensure t
    :general
    (mapleader
      "gf" '(forge-dispatch :which-key "Forge dispatch map.")))
#+end_src
**** git-timemachine
For going back through previous revisions of a file.
#+begin_src emacs-lisp
  (use-package git-timemachine
    :ensure t
    :general
    (mapleader
      "tg" '(git-timemachine-toggle :which-key "Toggle the time machine on or off.")))
#+end_src
**** Git Flow
#+begin_src emacs-lisp
  (use-package magit-gitflow
    :ensure t
    :hook (magit-mode . turn-on-magit-gitflow))
#+end_src
** Emacs Internals
*** User Information
Tell Emacs who you are, as well as some other things.
#+begin_src emacs-lisp
  (setc user-full-name "Hunter Jozwiak"
        user-mail-address "hunter.t.joz@gmail.com"
        user-login-name "sektor")
#+end_src
*** Short Ansers
When Emacs pops up a dialog for serious actions, such as deleting a file, it will expect an answer that is either yes or no, instead of the y or n prompt. The use-short-answers allows those prompts to be answered with either y or n.
#+begin_src emacs-lisp
  (setc use-short-answers t)
#+end_src
*** Basic Programming Things
**** No Indent of Tabs
I don't really care for tabs, so let's turn it off.
#+begin_src emacs-lisp
  (customize-set-variable 'indent-tabs-mode nil)
#+end_src
**** Eldoc Tweaks
By default, Eldoc is really spammy. Let's have it write to a buffer instead, and read from that buffer when things are changed.
#+begin_src emacs-lisp
  (use-package eldoc
    :init
    ;; Bookkeeping
    (defvar sonarmacs--last-spoken-eldoc-message nil "The last documentation that we spoke.")
    (defun sonarmacs--speak-eldoc (docs interactive)
      "Speak the eldoc documentation from the buffer.

  If the documentation strings are the same as before, i.e., the symbol has not changed, do not respeak them; the user can go back and view the buffer if they like."
      (when (and eldoc--doc-buffer (buffer-live-p eldoc--doc-buffer))
        (with-current-buffer eldoc--doc-buffer
        (unless (equal sonarmacs--last-spoken-eldoc-message eldoc--doc-buffer-docs)
          (speechd-say-text (buffer-string) :priority 'important)
          (setq sonarmacs--last-spoken-eldoc-message docs)))))
    :ghook
    ('eldoc-display-functions (list #'sonarmacs--speak-eldoc #'eldoc-display-in-buffer))
    :custom
    (eldoc-echo-area-prefer-doc-buffer t)
    :config
    (remove-hook 'eldoc-display-functions #'eldoc-display-in-echo-area))
#+end_src

